local function a(b)local c=setmetatable({},{__index=_ENV or getfenv()})if setfenv then setfenv(b,c)end;return b(c)or c end;local bit=a(function(_ENV,...)local d=math.floor;local e,f;f=function(g,h)return d(g%4294967296/2^h)end;e=function(g,h)return g*2^h%4294967296 end;return{bnot=bit.bnot,band=bit.band,bor=bit.bor,bxor=bit.bxor,rshift=f,lshift=e}end)local i=a(function(_ENV,...)local j=bit.bxor;local e=bit.lshift;local k=0x100;local l=0xff;local m=0x11b;local n={}local o={}local function p(q,r)return j(q,r)end;local function s(q,r)return j(q,r)end;local function t(u)if u==1 then return 1 end;local v=l-o[u]return n[v]end;local function x(q,r)if q==0 or r==0 then return 0 end;local v=o[q]+o[r]if v>=l then v=v-l end;return n[v]end;local function y(q,r)if q==0 then return 0 end;local v=o[q]-o[r]if v<0 then v=v+l end;return n[v]end;local function z()for A=1,k do print("log(",A-1,")=",o[A-1])end end;local function B()for A=1,k do print("exp(",A-1,")=",n[A-1])end end;local function C()local g=1;for A=0,l-1 do n[A]=g;o[g]=A;g=j(e(g,1),g)if g>l then g=s(g,m)end end end;C()return{add=p,sub=s,invert=t,mul=x,div=dib,printLog=z,printExp=B}end)util=a(function(_ENV,...)local j=bit.bxor;local f=bit.rshift;local D=bit.band;local e=bit.lshift;local E;local function F(byte)byte=j(byte,f(byte,4))byte=j(byte,f(byte,2))byte=j(byte,f(byte,1))return D(byte,1)end;local function G(H,I)if I==0 then return D(H,0xff)else return D(f(H,I*8),0xff)end end;local function J(H,I)if I==0 then return D(H,0xff)else return e(D(H,0xff),I*8)end end;local function K(L,M,k)local N={}for A=0,k-1 do N[A+1]=J(L[M+A*4],3)+J(L[M+A*4+1],2)+J(L[M+A*4+2],1)+J(L[M+A*4+3],0)if k%10000==0 then E()end end;return N end;local function O(N,P,Q,k)k=k or#N;for A=0,k-1 do for R=0,3 do P[Q+A*4+3-R]=G(N[A+1],R)end;if k%10000==0 then E()end end;return P end;local function S(L)local T=""for A,byte in ipairs(L)do T=T..string.format("%02x ",byte)end;return T end;local function U(L)local V={}for A=1,#L,2 do V[#V+1]=tonumber(L:sub(A,A+1),16)end;return V end;local function W(X)local type=type(X)if type=="number"then return string.format("%08x",X)elseif type=="table"then return S(X)elseif type=="string"then local L={string.byte(X,1,#X)}return S(L)else return X end end;local function Y(X)local Z=#X;local _=math.random(0,255)local a0=math.random(0,255)local a1=string.char(_,a0,_,a0,G(Z,3),G(Z,2),G(Z,1),G(Z,0))X=a1 ..X;local a2=math.ceil(#X/16)*16-#X;local a3=""for A=1,a2 do a3=a3 ..string.char(math.random(0,255))end;return X..a3 end;local function a4(X)local a5={string.byte(X,1,4)}if a5[1]==a5[3]and a5[2]==a5[4]then return true end;return false end;local function a6(X)if not a4(X)then return nil end;local Z=J(string.byte(X,5),3)+J(string.byte(X,6),2)+J(string.byte(X,7),1)+J(string.byte(X,8),0)return string.sub(X,9,8+Z)end;local function a7(X,a8)for A=1,16 do X[A]=j(X[A],a8[A])end end;local function a9(X)local A=16;while true do local aa=X[A]+1;if aa>=256 then X[A]=aa-256;A=(A-2)%16+1 else X[A]=aa;break end end end;local ab,ac,ad=os.queueEvent,coroutine.yield,os.time;local ae=ad()local function E()local af=ad()if af-ae>=0.03 then ae=af;ab("sleep")ac("sleep")end end;local function ag(L)local ah,a5,ai,aj=string.char,math.random,E,table.insert;local result={}for A=1,L do aj(result,a5(0,255))if A%10240==0 then ai()end end;return result end;local function ak(L)local ah,a5,ai,aj=string.char,math.random,E,table.insert;local result={}for A=1,L do aj(result,ah(a5(0,255)))if A%10240==0 then ai()end end;return table.concat(result)end;return{byteParity=F,getByte=G,putByte=J,bytesToInts=K,intsToBytes=O,bytesToHex=S,hexToBytes=U,toHexString=W,padByteString=Y,properlyDecrypted=a4,unpadByteString=a6,xorIV=a7,increment=a9,sleepCheckIn=E,getRandomData=ag,getRandomString=ak}end)aes=a(function(_ENV,...)local J=util.putByte;local G=util.getByte;local al='rounds'local am="type"local an=1;local ao=2;local ap={}local aq={}local ar={}local as={}local at={}local au={}local av={}local aw={}local ax={}local ay={}local az={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000,0xab000000,0x4d000000,0x9a000000,0x2f000000}local function aA(byte)mask=0xf8;result=0;for A=1,8 do result=bit.lshift(result,1)parity=util.byteParity(bit.band(byte,mask))result=result+parity;lastbit=bit.band(mask,1)mask=bit.band(bit.rshift(mask,1),0xff)if lastbit~=0 then mask=bit.bor(mask,0x80)else mask=bit.band(mask,0x7f)end end;return bit.bxor(result,0x63)end;local function aB()for A=0,255 do if A~=0 then inverse=i.invert(A)else inverse=A end;mapped=aA(inverse)ap[A]=mapped;aq[mapped]=A end end;local function aC()for aD=0,255 do byte=ap[aD]ar[aD]=J(i.mul(0x03,byte),0)+J(byte,1)+J(byte,2)+J(i.mul(0x02,byte),3)as[aD]=J(byte,0)+J(byte,1)+J(i.mul(0x02,byte),2)+J(i.mul(0x03,byte),3)at[aD]=J(byte,0)+J(i.mul(0x02,byte),1)+J(i.mul(0x03,byte),2)+J(byte,3)au[aD]=J(i.mul(0x02,byte),0)+J(i.mul(0x03,byte),1)+J(byte,2)+J(byte,3)end end;local function aE()for aD=0,255 do byte=aq[aD]av[aD]=J(i.mul(0x0b,byte),0)+J(i.mul(0x0d,byte),1)+J(i.mul(0x09,byte),2)+J(i.mul(0x0e,byte),3)aw[aD]=J(i.mul(0x0d,byte),0)+J(i.mul(0x09,byte),1)+J(i.mul(0x0e,byte),2)+J(i.mul(0x0b,byte),3)ax[aD]=J(i.mul(0x09,byte),0)+J(i.mul(0x0e,byte),1)+J(i.mul(0x0b,byte),2)+J(i.mul(0x0d,byte),3)ay[aD]=J(i.mul(0x0e,byte),0)+J(i.mul(0x0b,byte),1)+J(i.mul(0x0d,byte),2)+J(i.mul(0x09,byte),3)end end;local function aF(aG)local aH=bit.band(aG,0xff000000)return bit.lshift(aG,8)+bit.rshift(aH,24)end;local function aI(aG)return J(ap[G(aG,0)],0)+J(ap[G(aG,1)],1)+J(ap[G(aG,2)],2)+J(ap[G(aG,3)],3)end;local function aJ(aK)local aL={}local aM=math.floor(#aK/4)if aM~=4 and aM~=6 and aM~=8 or aM*4~=#aK then error("Invalid key size: "..tostring(aM))return nil end;aL[al]=aM+6;aL[am]=an;for A=0,aM-1 do aL[A]=J(aK[A*4+1],3)+J(aK[A*4+2],2)+J(aK[A*4+3],1)+J(aK[A*4+4],0)end;for A=aM,(aL[al]+1)*4-1 do local aH=aL[A-1]if A%aM==0 then aH=aF(aH)aH=aI(aH)local I=math.floor(A/aM)aH=bit.bxor(aH,az[I])elseif aM>6 and A%aM==4 then aH=aI(aH)end;aL[A]=bit.bxor(aL[A-aM],aH)end;return aL end;local function aN(aG)local aO=G(aG,3)local aP=G(aG,2)local aQ=G(aG,1)local aR=G(aG,0)return J(i.add(i.add(i.add(i.mul(0x0b,aP),i.mul(0x0d,aQ)),i.mul(0x09,aR)),i.mul(0x0e,aO)),3)+J(i.add(i.add(i.add(i.mul(0x0b,aQ),i.mul(0x0d,aR)),i.mul(0x09,aO)),i.mul(0x0e,aP)),2)+J(i.add(i.add(i.add(i.mul(0x0b,aR),i.mul(0x0d,aO)),i.mul(0x09,aP)),i.mul(0x0e,aQ)),1)+J(i.add(i.add(i.add(i.mul(0x0b,aO),i.mul(0x0d,aP)),i.mul(0x09,aQ)),i.mul(0x0e,aR)),0)end;local function aS(aG)local aO=G(aG,3)local aP=G(aG,2)local aQ=G(aG,1)local aR=G(aG,0)local aT=bit.bxor(aR,aQ)local aU=bit.bxor(aP,aO)local aV=bit.bxor(aT,aU)aV=bit.bxor(aV,i.mul(0x08,aV))w=bit.bxor(aV,i.mul(0x04,bit.bxor(aQ,aO)))aV=bit.bxor(aV,i.mul(0x04,bit.bxor(aR,aP)))return J(bit.bxor(bit.bxor(aR,aV),i.mul(0x02,bit.bxor(aO,aR))),0)+J(bit.bxor(bit.bxor(aQ,w),i.mul(0x02,aT)),1)+J(bit.bxor(bit.bxor(aP,aV),i.mul(0x02,bit.bxor(aO,aR))),2)+J(bit.bxor(bit.bxor(aO,w),i.mul(0x02,aU)),3)end;local function aW(aK)local aL=aJ(aK)if aL==nil then return nil end;aL[am]=ao;for A=4,(aL[al]+1)*4-5 do aL[A]=aN(aL[A])end;return aL end;local function aX(aY,aK,aZ)for A=0,3 do aY[A+1]=bit.bxor(aY[A+1],aK[aZ*4+A])end end;local function a_(b0,b1)b1[1]=bit.bxor(bit.bxor(bit.bxor(ar[G(b0[1],3)],as[G(b0[2],2)]),at[G(b0[3],1)]),au[G(b0[4],0)])b1[2]=bit.bxor(bit.bxor(bit.bxor(ar[G(b0[2],3)],as[G(b0[3],2)]),at[G(b0[4],1)]),au[G(b0[1],0)])b1[3]=bit.bxor(bit.bxor(bit.bxor(ar[G(b0[3],3)],as[G(b0[4],2)]),at[G(b0[1],1)]),au[G(b0[2],0)])b1[4]=bit.bxor(bit.bxor(bit.bxor(ar[G(b0[4],3)],as[G(b0[1],2)]),at[G(b0[2],1)]),au[G(b0[3],0)])end;local function b2(b0,b1)b1[1]=J(ap[G(b0[1],3)],3)+J(ap[G(b0[2],2)],2)+J(ap[G(b0[3],1)],1)+J(ap[G(b0[4],0)],0)b1[2]=J(ap[G(b0[2],3)],3)+J(ap[G(b0[3],2)],2)+J(ap[G(b0[4],1)],1)+J(ap[G(b0[1],0)],0)b1[3]=J(ap[G(b0[3],3)],3)+J(ap[G(b0[4],2)],2)+J(ap[G(b0[1],1)],1)+J(ap[G(b0[2],0)],0)b1[4]=J(ap[G(b0[4],3)],3)+J(ap[G(b0[1],2)],2)+J(ap[G(b0[2],1)],1)+J(ap[G(b0[3],0)],0)end;local function b3(b0,b1)b1[1]=bit.bxor(bit.bxor(bit.bxor(av[G(b0[1],3)],aw[G(b0[4],2)]),ax[G(b0[3],1)]),ay[G(b0[2],0)])b1[2]=bit.bxor(bit.bxor(bit.bxor(av[G(b0[2],3)],aw[G(b0[1],2)]),ax[G(b0[4],1)]),ay[G(b0[3],0)])b1[3]=bit.bxor(bit.bxor(bit.bxor(av[G(b0[3],3)],aw[G(b0[2],2)]),ax[G(b0[1],1)]),ay[G(b0[4],0)])b1[4]=bit.bxor(bit.bxor(bit.bxor(av[G(b0[4],3)],aw[G(b0[3],2)]),ax[G(b0[2],1)]),ay[G(b0[1],0)])end;local function b4(b0,b1)b1[1]=J(aq[G(b0[1],3)],3)+J(aq[G(b0[4],2)],2)+J(aq[G(b0[3],1)],1)+J(aq[G(b0[2],0)],0)b1[2]=J(aq[G(b0[2],3)],3)+J(aq[G(b0[1],2)],2)+J(aq[G(b0[4],1)],1)+J(aq[G(b0[3],0)],0)b1[3]=J(aq[G(b0[3],3)],3)+J(aq[G(b0[2],2)],2)+J(aq[G(b0[1],1)],1)+J(aq[G(b0[4],0)],0)b1[4]=J(aq[G(b0[4],3)],3)+J(aq[G(b0[3],2)],2)+J(aq[G(b0[2],1)],1)+J(aq[G(b0[1],0)],0)end;local function encrypt(aK,b5,b6,P,Q)b6=b6 or 1;P=P or{}Q=Q or 1;local aY={}local b7={}if aK[am]~=an then error("No encryption key: "..tostring(aK[am])..", expected "..an)return end;aY=util.bytesToInts(b5,b6,4)aX(aY,aK,0)local aZ=1;while aZ<aK[al]-1 do a_(aY,b7)aX(b7,aK,aZ)aZ=aZ+1;a_(b7,aY)aX(aY,aK,aZ)aZ=aZ+1 end;a_(aY,b7)aX(b7,aK,aZ)aZ=aZ+1;b2(b7,aY)aX(aY,aK,aZ)util.sleepCheckIn()return util.intsToBytes(aY,P,Q)end;local function decrypt(aK,b5,b6,P,Q)b6=b6 or 1;P=P or{}Q=Q or 1;local aY={}local b7={}if aK[am]~=ao then error("No decryption key: "..tostring(aK[am]))return end;aY=util.bytesToInts(b5,b6,4)aX(aY,aK,aK[al])local aZ=aK[al]-1;while aZ>2 do b3(aY,b7)aX(b7,aK,aZ)aZ=aZ-1;b3(b7,aY)aX(aY,aK,aZ)aZ=aZ-1 end;b3(aY,b7)aX(b7,aK,aZ)aZ=aZ-1;b4(b7,aY)aX(aY,aK,aZ)util.sleepCheckIn()return util.intsToBytes(aY,P,Q)end;aB()aC()aE()return{ROUNDS=al,KEY_TYPE=am,ENCRYPTION_KEY=an,DECRYPTION_KEY=ao,expandEncryptionKey=aJ,expandDecryptionKey=aW,encrypt=encrypt,decrypt=decrypt}end)local b8=a(function(_ENV,...)local function b9()return{}end;local function ba(bb,bc)table.insert(bb,bc)end;local function bd(bb)return table.concat(bb)end;return{new=b9,addString=ba,toString=bd}end)ciphermode=a(function(_ENV,...)local be={}local a5=math.random;function be.encryptString(aK,X,bf,a8)if a8 then local bg={}for A=1,16 do bg[A]=a8[A]end;a8=bg else a8={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}end;local bh=aes.expandEncryptionKey(aK)local bi=b8.new()for A=1,#X/16 do local bj=(A-1)*16+1;local bk={string.byte(X,bj,bj+15)}a8=bf(bh,bk,a8)b8.addString(bi,string.char(unpack(bk)))end;return b8.toString(bi)end;function be.encryptECB(bh,bk,a8)aes.encrypt(bh,bk,1,bk,1)end;function be.encryptCBC(bh,bk,a8)util.xorIV(bk,a8)aes.encrypt(bh,bk,1,bk,1)return bk end;function be.encryptOFB(bh,bk,a8)aes.encrypt(bh,a8,1,a8,1)util.xorIV(bk,a8)return a8 end;function be.encryptCFB(bh,bk,a8)aes.encrypt(bh,a8,1,a8,1)util.xorIV(bk,a8)return bk end;function be.encryptCTR(bh,bk,a8)local bl={}for R=1,16 do bl[R]=a8[R]end;aes.encrypt(bh,a8,1,a8,1)util.xorIV(bk,a8)util.increment(bl)return bl end;function be.decryptString(aK,X,bf,a8)if a8 then local bg={}for A=1,16 do bg[A]=a8[A]end;a8=bg else a8={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}end;local bh;if bf==be.decryptOFB or bf==be.decryptCFB or bf==be.decryptCTR then bh=aes.expandEncryptionKey(aK)else bh=aes.expandDecryptionKey(aK)end;local bm=b8.new()for A=1,#X/16 do local bj=(A-1)*16+1;local bk={string.byte(X,bj,bj+15)}a8=bf(bh,bk,a8)b8.addString(bm,string.char(unpack(bk)))end;return b8.toString(bm)end;function be.decryptECB(bh,bk,a8)aes.decrypt(bh,bk,1,bk,1)return a8 end;function be.decryptCBC(bh,bk,a8)local bl={}for R=1,16 do bl[R]=bk[R]end;aes.decrypt(bh,bk,1,bk,1)util.xorIV(bk,a8)return bl end;function be.decryptOFB(bh,bk,a8)aes.encrypt(bh,a8,1,a8,1)util.xorIV(bk,a8)return a8 end;function be.decryptCFB(bh,bk,a8)local bl={}for R=1,16 do bl[R]=bk[R]end;aes.encrypt(bh,a8,1,a8,1)util.xorIV(bk,a8)return bl end;be.decryptCTR=be.encryptCTR;return be end)AES128=16;AES192=24;AES256=32;ECBMODE=1;CBCMODE=2;OFBMODE=3;CFBMODE=4;CTRMODE=4;local function bn(bo,bp,a8)local bq=bp;if bp==AES192 then bq=32 end;if bq>#bo then local br=""for A=1,bq-#bo do br=br..string.char(0)end;bo=bo..br else bo=string.sub(bo,1,bq)end;local bs={string.byte(bo,1,#bo)}bo=ciphermode.encryptString(bs,bo,ciphermode.encryptCBC,a8)bo=string.sub(bo,1,bp)return{string.byte(bo,1,#bo)}end;function encrypt(bo,X,bp,bt,a8)assert(bo~=nil,"Empty password.")assert(bo~=nil,"Empty data.")local bt=bt or CBCMODE;local bp=bp or AES128;local aK=bn(bo,bp,a8)local bu=util.padByteString(X)if bt==ECBMODE then return ciphermode.encryptString(aK,bu,ciphermode.encryptECB,a8)elseif bt==CBCMODE then return ciphermode.encryptString(aK,bu,ciphermode.encryptCBC,a8)elseif bt==OFBMODE then return ciphermode.encryptString(aK,bu,ciphermode.encryptOFB,a8)elseif bt==CFBMODE then return ciphermode.encryptString(aK,bu,ciphermode.encryptCFB,a8)elseif bt==CTRMODE then return ciphermode.encryptString(aK,bu,ciphermode.encryptCTR,a8)else error("Unknown mode",2)end end;function decrypt(bo,X,bp,bt,a8)local bt=bt or CBCMODE;local bp=bp or AES128;local aK=bn(bo,bp,a8)local bv;if bt==ECBMODE then bv=ciphermode.decryptString(aK,X,ciphermode.decryptECB,a8)elseif bt==CBCMODE then bv=ciphermode.decryptString(aK,X,ciphermode.decryptCBC,a8)elseif bt==OFBMODE then bv=ciphermode.decryptString(aK,X,ciphermode.decryptOFB,a8)elseif bt==CFBMODE then bv=ciphermode.decryptString(aK,X,ciphermode.decryptCFB,a8)elseif bt==CTRMODE then bv=ciphermode.decryptString(aK,X,ciphermode.decryptCTR,a8)else error("Unknown mode",2)end;result=util.unpadByteString(bv)if result==nil then return nil end;return result end;function AESWritefile(bw,bx,by)return pcall(writefile,bw,encrypt(by,bx,32,nil,nil,nil))end;function AESReadfile(bw,by)return decrypt(by,readfile(bw),32,nil,nil,nil)end;return{Writefile=AESWritefile,Readfile=AESReadfile}
